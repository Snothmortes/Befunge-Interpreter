// <auto-generated />
// Refactor

namespace Befunge_Interpreter
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Data;
    using System.Diagnostics;
    using System.Linq;
    using System.Text;
    using static Befunge_Interpreter.BefungeInterpreter;

    public class BefungeInterpreter
    {
        private Direction _currentDirection = Direction.Right;
        private Instruction _theInstruction;
        private Stack<int> _theStack;
        private StringBuilder _theOutput;
        private Random _random;
        private bool _stringMode;

        public string Interpret(string code)
        {
            Initialize(code);
            char[] movers = new char[] { '<', '>', '^', 'v' };
            while (true)
            {
                char currentChar = _theInstruction.CurrentChar;
                Debug.WriteLine("Char: " + currentChar);
                if (_stringMode)
                    _theStack.Push(_theInstruction.CurrentChar);
                else if (Char.IsLetter(currentChar) && !new char[] { 'p', 'g', 'v' }.Contains(currentChar))
                    _theStack.Push(_theInstruction.CurrentChar);
                if (Char.IsDigit(_theInstruction.CurrentChar))
                    _theStack.Push(_theInstruction.CurrentChar - 48);
                else if (movers.Contains(_theInstruction.CurrentChar))
                    SetDirection(_theInstruction.CurrentChar);
                else if (_stringMode)
                    _theStack.Push(_theInstruction.CurrentChar);
                else if (new char[] { '+', '-', '*', '/', '%' }.Contains(_theInstruction.CurrentChar))
                {
                    var dt = new DataTable();
                    var a = _theStack.Pop();
                    var b = _theStack.Pop();
                    var eval = _theInstruction.CurrentChar == '/' && a == 0 ? 0 : (int)Math.Floor(Convert.ToDouble(dt.Compute($"{b}{_theInstruction.CurrentChar}{a}", "")));
                    _theStack.Push(eval);
                }
                else if (_theInstruction.CurrentChar == '`')
                {
                    var dt = new DataTable();
                    var a = _theStack.Pop();
                    var b = _theStack.Pop();
                    _theStack.Push(b > a ? 1 : 0);
                }
                else if (_theInstruction.CurrentChar == '!')
                {
                    var a = _theStack.Pop();
                    _theStack.Push(a == 0 ? 1 : 0);
                }
                else if (_theInstruction.CurrentChar == '?')
                {
                    var next = _random.Next(0,3);
                    var randomChar = movers[next];
                    SetDirection(randomChar);
                }
                else if (_theInstruction.CurrentChar == '_')
                {
                    if (_theStack.Pop() == 0)
                        SetDirection('>');
                    else
                        SetDirection('<');
                }
                else if (_theInstruction.CurrentChar == '|')
                {
                    if (_theStack.Pop() == 0)
                        SetDirection('v');
                    else
                        SetDirection('^');
                }
                else if (_theInstruction.CurrentChar == '"')
                {
                    _stringMode = true;
                    _theInstruction.Move(_currentDirection);
                    do
                    {
                        Interpret(code);
                    } while (_theInstruction.CurrentChar != '"');
                    _stringMode = false;
                }
                else if (_theInstruction.CurrentChar == ':')
                {
                    if (_theStack.Count == 0)
                        _theStack.Push(0);
                    else
                        _theStack.Push(_theStack.Peek());
                }
                else if (_theInstruction.CurrentChar == '\\')
                {
                    var b = _theStack.Pop();
                    var a = _theStack.Pop();
                    _theStack.Push(b);
                    _theStack.Push(a);
                }
                else if (_theInstruction.CurrentChar == '$')
                    _theStack.Pop();
                else if (_theInstruction.CurrentChar == '.')
                    _theOutput.Append(_theStack.Pop().ToString());
                else if (_theInstruction.CurrentChar == ',')
                    _theOutput.Append(((char)_theStack.Pop()).ToString());
                else if (_theInstruction.CurrentChar == '#')
                    _theInstruction.Move(_currentDirection);
                else if (_theInstruction.CurrentChar == 'p')
                {
                    var y = _theStack.Pop();
                    var x = _theStack.Pop();
                    var v = _theStack.Pop();
                    _theInstruction.SetCharAtPoint(new Point(x, y), (char)v);
                }
                else if (_theInstruction.CurrentChar == 'g')
                {
                    var y = _theStack.Pop();
                    var x = _theStack.Pop();
                    _theStack.Push((char)_theInstruction.GetCharAtPoint(new Point(x, y)));
                }
                else if (_theInstruction.CurrentChar == '@')
                    break;

                if (!_stringMode)
                    _theInstruction.Move(_currentDirection);
                else
                {
                    _theInstruction.Move(_currentDirection);
                    return _theStack.Pop().ToString();
                }
            }
            return _theOutput.ToString();
        }

        private void Initialize(string code)
        {
            _theInstruction = _theInstruction ?? new Instruction(code);
            _theStack = _theStack ?? new Stack<int>();
            _theOutput = _theOutput ?? new StringBuilder();
            _random = _random ?? new Random();
        }

        private void SetDirection(char @char)
        {
            switch (@char)
            {
                case '<':
                    _currentDirection = Direction.Left;
                    break;
                case '^':
                    _currentDirection = Direction.Up;
                    break;
                case '>':
                    _currentDirection = Direction.Right;
                    break;
                case 'v':
                    _currentDirection = Direction.Down;
                    break;
                default:
                    break;
            }
        }

        public enum Direction
        {
            Left,
            Up,
            Right,
            Down,
        }
    }

    internal class Instruction
    {
        private string[] _array;
        private Point _currentPoint;

        public Instruction(string code)
        {
            _array = code.Split('\n');
            _currentPoint = new Point(0, 0);
        }

        internal char CurrentChar => _array[_currentPoint.Row][_currentPoint.Column];
        internal char GetCharAtPoint(Point point) => _array[point.Row][point.Column];
        internal void SetCharAtPoint(Point point, char v)
        {
            
            var sb = new StringBuilder(_array[point.Row]);
            sb.Remove(point.Column, 1);
            sb.Insert(point.Column, v);
            _array[point.Row] = sb.ToString();
        }

        public Point CurrentPoint { get { return _currentPoint; } private set { _currentPoint = value; } }

        internal void Move(BefungeInterpreter.Direction currentDirection)
        {
            switch (currentDirection)
            {
                case Direction.Left:
                    if (_currentPoint.Column > 0)
                        _currentPoint.Column--;
                    else
                        throw new Exception("Invalid left move. Review code and recompile.");
                    break;
                case Direction.Up:
                    if (_currentPoint.Row > 0)
                        _currentPoint.Row--;
                    else
                        throw new Exception("Invalid up move. Review code and recompile.");
                    break;
                case Direction.Right:
                    if (_currentPoint.Column < _array[_currentPoint.Row].Length)
                        _currentPoint.Column++;
                    else
                        throw new Exception("Invalid right move. Review code and recompile.");
                    break;
                case Direction.Down:
                    if (_currentPoint.Row < _array.Length)
                        _currentPoint.Row++;
                    else
                        throw new Exception("Invalid down move. Review code and recompile.");
                    break;
                default:
                    break;
            }
        }
    }

    internal class Point
    {
        private int _row;
        private int _column;

        public Point(int row, int column)
        {
            _row = row;
            _column = column;
        }

        public int Row { get { return _row; } set { _row = value; } }
        public int Column { get { return _column; } set { _column = value; } }

    }
}