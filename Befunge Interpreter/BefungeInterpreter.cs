// <auto-generated />
// Refactor branch

namespace Befunge_Interpreter
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Data;
    using System.Diagnostics;
    using System.Linq;
    using System.Text;
    using static Befunge_Interpreter.BefungeInterpreter;

    public class BefungeInterpreter
    {
        private Direction _currentDirection = Direction.Right;
        private Instruction _theInstruction;
        private Stack<int> _theStack;
        private StringBuilder _theOutput;
        private Random _random;
        private bool _stringMode;

        public string Interpret(string code)
        {
            Initialize(code);
            char[] movers = new char[] { '<', '>', '^', 'v' };
            while (true)
            {
                char currentChar = _theInstruction.CurrentChar;
                Debug.WriteLine("Char: " + currentChar);
                if (_stringMode)
                    _theStack.Push(_theInstruction.CurrentChar);
                else if (Char.IsLetter(currentChar) && !new char[] { 'p', 'g', 'v' }.Contains(currentChar))
                    _theStack.Push(_theInstruction.CurrentChar);
                if (Char.IsDigit(_theInstruction.CurrentChar))
                    _theStack.Push(_theInstruction.CurrentChar - 48);
                else if (movers.Contains(_theInstruction.CurrentChar))
                    SetDirection(_theInstruction.CurrentChar);
                else if (_stringMode)
                    _theStack.Push(_theInstruction.CurrentChar);
                if (_theInstruction.CurrentChar == '@')
                    break;

                switch (_theInstruction.CurrentChar)
                {
                    case '+':
                    case '-':
                    case '*':
                    case '/':
                    case '%':
                        var dt = new DataTable();
                        var a = _theStack.Pop();
                        var b = _theStack.Pop();
                        var eval = _theInstruction.CurrentChar == '/' && a == 0 ? 0 : (int)Math.Floor(Convert.ToDouble(dt.Compute($"{b}{_theInstruction.CurrentChar}{a}", "")));
                        _theStack.Push(eval);
                        break;
                    case '`':
                        dt = new DataTable();
                        a = _theStack.Pop();
                        b = _theStack.Pop();
                        _theStack.Push(b > a ? 1 : 0);
                        break;
                    case '!':
                        a = _theStack.Pop();
                        _theStack.Push(a == 0 ? 1 : 0);
                        break;
                    case '?':
                        var next = _random.Next(0, 3);
                        var randomChar = movers[next];
                        SetDirection(randomChar);
                        break;
                    case '_':
                        if (_theStack.Pop() == 0)
                            SetDirection('>');
                        else
                            SetDirection('<');
                        break;
                    case '|':
                        if (_theStack.Pop() == 0)
                            SetDirection('v');
                        else
                            SetDirection('^');
                        break;
                    case '"':
                        _stringMode = true;
                        _theInstruction.Move(_currentDirection);
                        do
                        {
                            Interpret(code);
                        } while (_theInstruction.CurrentChar != '"');
                        _stringMode = false;
                        break;
                    case ':':
                        if (_theStack.Count == 0)
                            _theStack.Push(0);
                        else
                            _theStack.Push(_theStack.Peek());
                        break;
                    case '$':
                        _theStack.Pop();
                        break;
                    case '\\':
                        b = _theStack.Pop();
                        a = _theStack.Pop();
                        _theStack.Push(b);
                        _theStack.Push(a);
                        break;
                    case '.':
                        _theOutput.Append(_theStack.Pop().ToString());
                        break;
                    case ',':
                        _theOutput.Append(((char)_theStack.Pop()).ToString());
                        break;
                    case '#':
                        _theInstruction.Move(_currentDirection);
                        break;
                    case 'p':
                        var y = _theStack.Pop();
                        var x = _theStack.Pop();
                        var v = _theStack.Pop();
                        _theInstruction.SetCharAtPoint(new Point(x, y), (char)v);
                        break;
                    case 'g':
                        y = _theStack.Pop();
                        x = _theStack.Pop();
                        _theStack.Push((char)_theInstruction.GetCharAtPoint(new Point(x, y)));
                        break;
                }

                if (!_stringMode)
                    _theInstruction.Move(_currentDirection);
                else
                {
                    _theInstruction.Move(_currentDirection);
                    return _theStack.Pop().ToString();
                }
            }
            return _theOutput.ToString();
        }

        private void Initialize(string code)
        {
            _theInstruction = _theInstruction ?? new Instruction(code);
            _theStack = _theStack ?? new Stack<int>();
            _theOutput = _theOutput ?? new StringBuilder();
            _random = _random ?? new Random();
        }

        private void SetDirection(char @char)
        {
            switch (@char)
            {
                case '<':
                    _currentDirection = Direction.Left;
                    break;
                case '^':
                    _currentDirection = Direction.Up;
                    break;
                case '>':
                    _currentDirection = Direction.Right;
                    break;
                case 'v':
                    _currentDirection = Direction.Down;
                    break;
                default:
                    break;
            }
        }

        public enum Direction
        {
            Left,
            Up,
            Right,
            Down,
        }
    }

    internal class Instruction
    {
        private string[] _array;
        private Point _currentPoint;

        public Instruction(string code)
        {
            _array = code.Split('\n');
            _currentPoint = new Point(0, 0);
        }

        internal char CurrentChar => _array[_currentPoint.Row][_currentPoint.Column];
        internal char GetCharAtPoint(Point point) => _array[point.Row][point.Column];
        internal void SetCharAtPoint(Point point, char v)
        {

            var sb = new StringBuilder(_array[point.Row]);
            sb.Remove(point.Column, 1);
            sb.Insert(point.Column, v);
            _array[point.Row] = sb.ToString();
        }

        public Point CurrentPoint { get { return _currentPoint; } private set { _currentPoint = value; } }

        internal void Move(BefungeInterpreter.Direction currentDirection)
        {
            switch (currentDirection)
            {
                case Direction.Left:
                    if (_currentPoint.Column > 0)
                        _currentPoint.Column--;
                    else
                        throw new Exception("Invalid left move. Review code and recompile.");
                    break;
                case Direction.Up:
                    if (_currentPoint.Row > 0)
                        _currentPoint.Row--;
                    else
                        throw new Exception("Invalid up move. Review code and recompile.");
                    break;
                case Direction.Right:
                    if (_currentPoint.Column < _array[_currentPoint.Row].Length)
                        _currentPoint.Column++;
                    else
                        throw new Exception("Invalid right move. Review code and recompile.");
                    break;
                case Direction.Down:
                    if (_currentPoint.Row < _array.Length)
                        _currentPoint.Row++;
                    else
                        throw new Exception("Invalid down move. Review code and recompile.");
                    break;
                default:
                    break;
            }
        }
    }

    internal class Point
    {
        private int _row;
        private int _column;

        public Point(int row, int column)
        {
            _row = row;
            _column = column;
        }

        public int Row { get { return _row; } set { _row = value; } }
        public int Column { get { return _column; } set { _column = value; } }

    }
}