// <auto-generated />
// Refactor branch

namespace Befunge_Interpreter
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;

    public class BefungeInterpreter
    {
        private Direction _currentDirection = Direction.Right;
        private Instruction _theInstruction;
        private Stack<int> _theStack;
        private string _theOutput;
        private bool _stringMode;

        public string Interpret(string code)
        {
            Initialize(code);
            var random = new Random();

            while (true)
            {
                char currentChar = _theInstruction.CurrentChar;

                if (_stringMode)
                {
                    _theStack.Push(currentChar);
                    _theInstruction.Move(_currentDirection);
                    return _theStack.Peek().ToString();
                }
                else if (Char.IsDigit(currentChar))
                    _theStack.Push(currentChar - 48);
                else if (currentChar == '@')
                    break;

                switch (currentChar) // What? It's O(1) for a small collection... 23 is a small collection
                {
                    case '+':
                    case '-':
                    case '*':
                    case '/':
                    case '%':
                        var a = _theStack.Pop();
                        var b = _theStack.Pop();
                        using (var dt = new System.Data.DataTable())
                        {
                            var eval = _theInstruction.CurrentChar == '/' && a == 0 ? 0 : (int)Math.Floor(Convert.ToDouble(dt.Compute($"{b}{_theInstruction.CurrentChar}{a}", "")));
                            _theStack.Push(eval);
                        }
                        break;
                    case '`':
                        a = _theStack.Pop();
                        b = _theStack.Pop();
                        _theStack.Push(b > a ? 1 : 0);
                        break;
                    case '<':
                    case '^':
                    case '>':
                    case 'v':
                        SetDirection(currentChar);
                        break;
                    case '?':
                        var next = random.Next(0, 3);
                        SetDirection(new char[] { '<', '^', '>', 'v', }[next]);
                        Console.WriteLine(next);
                        break;
                    case '!':
                        a = _theStack.Pop();
                        _theStack.Push(a == 0 ? 1 : 0);
                        break;
                    case '_':
                        if (_theStack.Pop() == 0)
                            SetDirection('>');
                        else
                            SetDirection('<');
                        break;
                    case '|':
                        if (_theStack.Pop() == 0)
                            SetDirection('v');
                        else
                            SetDirection('^');
                        break;
                    case '"':
                        _stringMode = true;
                        _theInstruction.Move(_currentDirection);
                        do
                        {
                            Interpret(code);
                        } while (_theInstruction.CurrentChar != '"');
                        _stringMode = false;
                        break;
                    case ':':
                        if (_theStack.Count == 0)
                            _theStack.Push(0);
                        else
                            _theStack.Push(_theStack.Peek());
                        break;
                    case '$':
                        _theStack.Pop();
                        break;
                    case '\\':
                        b = _theStack.Pop();
                        a = _theStack.Pop();
                        _theStack.Push(b);
                        _theStack.Push(a);
                        break;
                    case '.':
                        _theOutput += _theStack.Pop().ToString();
                        break;
                    case ',':
                        _theOutput += ((char)_theStack.Pop()).ToString();
                        break;
                    case '#':
                        _theInstruction.Move(_currentDirection);
                        Debug.WriteLine(_theInstruction.CurrentChar + " skipped.");
                        break;
                    case 'p':
                        var y = _theStack.Pop();
                        var x = _theStack.Pop();
                        var v = _theStack.Pop();
                        _theInstruction.SetCharAtPoint(new Point(y, x), (char)v);
                        break;
                    case 'g':
                        y = _theStack.Pop();
                        x = _theStack.Pop();
                        _theStack.Push((char)_theInstruction.GetCharAtPoint(new Point(y, x)));
                        break;
                    default:
                        break;
                }
                _theInstruction.Move(_currentDirection);
            }
            Console.WriteLine($"Output: {_theOutput}");
            return _theOutput;
        }

        private void Initialize(string code)
        {
            _theInstruction = _theInstruction ?? new Instruction(code);
            _theStack = _theStack ?? new Stack<int>();
        }

        private void SetDirection(char @char)
        {
            switch (@char)
            {
                case '<':
                    _currentDirection = Direction.Left;
                    break;
                case '^':
                    _currentDirection = Direction.Up;
                    break;
                case '>':
                    _currentDirection = Direction.Right;
                    break;
                case 'v':
                    _currentDirection = Direction.Down;
                    break;
                default:
                    break;
            }
        }

        public enum Direction
        {
            Left,
            Up,
            Right,
            Down,
        }
    }

    internal class Instruction
    {
        private string[] _array;
        private Point _currentPoint;

        public Instruction(string code)
        {
            _array = code.Split('\n');
            _currentPoint = new Point(0, 0);
        }

        internal char CurrentChar => _array[_currentPoint.Row][_currentPoint.Column];
        internal char GetCharAtPoint(Point point) => _array[point.Row][point.Column];
        internal void SetCharAtPoint(Point point, char v)
        {

            var sb = new System.Text.StringBuilder(_array[point.Row]);
            sb.Remove(point.Column, 1);
            sb.Insert(point.Column, v);
            _array[point.Row] = sb.ToString();
        }

        public Point CurrentPoint { get { return _currentPoint; } private set { _currentPoint = value; } }

        internal void Move(BefungeInterpreter.Direction currentDirection)
        {
            switch (currentDirection)
            {
                case BefungeInterpreter.Direction.Left:
                    if (_currentPoint.Column > 0)
                        _currentPoint.Column--;
                    else
                        throw new Exception("Invalid left move. Review code and recompile.");
                    break;
                case BefungeInterpreter.Direction.Up:
                    if (_currentPoint.Row > 0)
                        _currentPoint.Row--;
                    else
                        throw new Exception("Invalid up move. Review code and recompile.");
                    break;
                case BefungeInterpreter.Direction.Right:
                    if (_currentPoint.Column < _array[_currentPoint.Row].Length)
                        _currentPoint.Column++;
                    else
                        throw new Exception("Invalid right move. Review code and recompile.");
                    break;
                case BefungeInterpreter.Direction.Down:
                    if (_currentPoint.Row < _array.Length)
                        _currentPoint.Row++;
                    else
                        throw new Exception("Invalid down move. Review code and recompile.");
                    break;
                default:
                    break;
            }
        }
    }

    internal class Point
    {
        private int _row;
        private int _column;

        public Point(int row, int column)
        {
            _row = row;
            _column = column;
        }

        public int Row { get { return _row; } set { _row = value; } }
        public int Column { get { return _column; } set { _column = value; } }

    }
}